'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module auth/verifyPeer */
var EventEmitter = require('events');
var challengeHandler = require('./challenge');
var challengeParser = require('./challengeParser');
var VerifyResult = require('./VerifyResult');

var AuthPacketHandler = function () {
	function AuthPacketHandler(serverSocket, clientKeyPair, serverPublicKey) {
		var _this = this;

		_classCallCheck(this, AuthPacketHandler);

		this.serverSocket = serverSocket;
		this.clientKeyPair = clientKeyPair;
		this.serverPublicKey = serverPublicKey;
		this.securityMode = 1; // none (this is only mode currenty supported by upstream code)

		this.serverChallenge = undefined;
		this.hasRaisedVerifyEvent = false;
		this.emitter = new EventEmitter();

		// verify handshake requires successful processing of a server challenge and a client challenge
		this.authPacketHandlers = [function (packet) {
			return _this.dispatch(packet, {
				name: 'server',
				handler: _this.handleServerChallenge,
				tryParse: challengeParser.tryParseServerChallengeRequest
			});
		}, function (packet) {
			return _this.dispatch(packet, {
				name: 'client',
				handler: _this.handleClientChallenge,
				tryParse: challengeParser.tryParseClientChallengeResponse
			});
		}];
	}

	_createClass(AuthPacketHandler, [{
		key: 'process',
		value: function process(packet) {
			var handler = this.authPacketHandlers.shift();

			// if no handlers are left, the verify handshake is complete
			if (!handler) return;

			handler(packet);
		}
	}, {
		key: 'handleServerChallenge',
		value: function handleServerChallenge(packet) {
			var response = challengeHandler.generateServerChallengeResponse(packet, this.clientKeyPair, this.securityMode);
			this.serverChallenge = response.slice(8, 8 + 64);

			this.log('writing response of length: ' + response.length);
			this.serverSocket.write(response);
		}
	}, {
		key: 'handleClientChallenge',
		value: function handleClientChallenge(packet) {
			var isVerified = challengeHandler.verifyClientChallengeResponse(packet, this.serverPublicKey, this.serverChallenge);
			this.log('client challenge verified? ' + isVerified);
			this.raiseVerified(isVerified ? VerifyResult.success : VerifyResult.failedChallenge);
		}
	}, {
		key: 'dispatch',
		value: function dispatch(packet, traits) {
			var parsedPacket = traits.tryParse(packet);
			if (!parsedPacket) {
				this.log('unable to parse ' + traits.name + ' packet with type ' + packet.type + ' and size ' + packet.size);
				this.raiseVerified(VerifyResult.malformedData);
				return;
			}

			traits.handler.call(this, parsedPacket);
		}
	}, {
		key: 'log',
		value: function log(message) {
			this.emitter.emit('status', message);
		}
	}, {
		key: 'raiseVerified',
		value: function raiseVerified(result) {
			// only raise the verify event once
			if (this.hasRaisedVerifyEvent) return;

			this.hasRaisedVerifyEvent = true;
			this.emitter.emit('verify', result);
		}
	}]);

	return AuthPacketHandler;
}();

/**
 * Verifies a connection with a catapult server.
 * @class Verifier
 *
 * @fires status Messages about verification progress.
 * @fires verify The verification result.
 */

var verifyPeer = {
	/**
  * Creates a server verifier for performing a verification handshake with a catapult server.
  * @param {net.Socket} serverSocket A socket connection to the catapult server.
  * @param {module:crypto/keyPair~KeyPair} clientKeyPair The key pair of the connecting client.
  * @param {module:crypto/keyPair~PublicKey} serverPublicKey The public key of the catapult server.
  * @returns {module:auth/verifyPeer~Verifier} A verifier for the specified server.
  */
	createServerVerifier: function createServerVerifier(serverSocket, clientKeyPair, serverPublicKey) {
		var packetHandler = new AuthPacketHandler(serverSocket, clientKeyPair, serverPublicKey);
		var verifier = {
			/**
    * Accepts a server payload.
    * @param {Buffer} payload Data from the server.
    * @memberof module:auth/verifyPeer~Verifier
    * @instance
    */
			handler: function handler(payload) {
				packetHandler.process(payload);
			},

			/**
    * Subscribes to verifier events.
    * @param {string} eventName The name of the event.
    * @param {Function} eventHandler The function that should be called when the event is emitted.
    * @returns {module:auth/verifyPeer~Verifier} The verifier (for chaining).
    * @memberof module:auth/verifyPeer~Verifier
    * @instance
    */
			on: function on(eventName, eventHandler) {
				packetHandler.emitter.on(eventName, eventHandler);
				return verifier;
			}
		};

		return verifier;
	}
};

module.exports = verifyPeer;
//# sourceMappingURL=verifyPeer.js.map