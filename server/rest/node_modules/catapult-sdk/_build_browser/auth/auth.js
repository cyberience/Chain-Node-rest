'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module auth/auth */
var PacketParser = require('../parser/PacketParser');
var verifyPeer = require('./verifyPeer');
var VerifyResult = require('./VerifyResult');

/**
 * An error that indicates a failed verification handshake.
 * @property {module:auth/VerifyResult} verifyResult The result of a verify operation.
 */

var VerifyError = function (_Error) {
	_inherits(VerifyError, _Error);

	/**
  * Creates a new verify error.
  * @param {module:auth/VerifyResult} result The result of a verify operation.
  */
	function VerifyError(result) {
		_classCallCheck(this, VerifyError);

		var _this = _possibleConstructorReturn(this, (VerifyError.__proto__ || Object.getPrototypeOf(VerifyError)).call(this, 'verify failed with ' + result));

		_this.verifyResult = result;
		return _this;
	}

	return VerifyError;
}(Error);

var auth = {
	/**
  * Starts an authentication handshake with a catapult server.
  * @param {net.Socket} serverSocket A socket connection to the catapult server.
  * @param {module:crypto/keyPair~KeyPair} clientKeyPair The key pair of the connecting client.
  * @param {module:crypto/keyPair~PublicKey} serverPublicKey The public key of the catapult server.
  * @param {Function} [logger=empty] A logging function that is passed status messages.
  * @returns {Promise}
  * A promise that is completed when authentication completes and either resolved with a
  * {@link module:parser/PacketParser} on success or rejected with a
  * {@link module:auth/auth~VerifyError} on failure.
  */
	createAuthPromise: function createAuthPromise(serverSocket, clientKeyPair, serverPublicKey) {
		var logger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
		return new Promise(function (resolve, reject) {
			// create a verifier
			var verifier = verifyPeer.createServerVerifier(serverSocket, clientKeyPair, serverPublicKey);
			verifier.on('status', logger);

			// create a packet parser and forward packets to the verifier
			var parser = new PacketParser();
			parser.onPacket(verifier.handler);

			// hook server socket events
			serverSocket.on('data', function (data) {
				// send socket data to the parser
				logger('received data with size ' + data.length);
				parser.push(data);
			}).on('close', function () {
				// fail if the socket is closed
				reject(new VerifyError(VerifyResult.ioError));
			});

			verifier.on('verify', function (result) {
				// stop forwarding packets to the verifier
				parser.impl.emitter.removeListener('packet', verifier.handler);

				// on success, complete the promise with the parser
				if (VerifyResult.success === result) {
					resolve(parser);
					return;
				}

				// otherwise, fail and reject the promise
				var verifyError = new VerifyError(result);
				reject(verifyError);
				serverSocket.destroy(verifyError);
			});
		});
	}
};

module.exports = auth;
//# sourceMappingURL=auth.js.map