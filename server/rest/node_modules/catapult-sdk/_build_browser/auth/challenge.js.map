{"version":3,"sources":["../../src/auth/challenge.js"],"names":["crypto","require","sign","verify","packetHeader","PacketType","sizes","header","size","challenge","securityMode","challengeModule","generateServerChallengeResponse","request","keyPair","randomBytes","signedBuffers","Buffer","of","signature","concat","length","publicKey","createBuffer","serverChallenge","buffers","from","buffer","verifyClientChallengeResponse","response","generateServerChallengeRequest","verifyServerChallengeResponse","generateClientChallengeResponse","clientChallenge","module","exports"],"mappings":"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","file":"challenge.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/** @module auth/challenge */\nconst crypto = require('crypto');\nconst { sign, verify } = require('../crypto/keyPair');\nconst packetHeader = require('../packet/header');\nconst PacketType = require('../packet/PacketType');\n\nconst sizes = {\n\theader: packetHeader.size,\n\tchallenge: 64,\n\tsecurityMode: 1\n};\n\nconst challengeModule = {\n\t// region verify server challenges\n\n\t/**\n\t * Generates a client response to a server challenge.\n\t * @param {object} request The parsed server challenge request.\n\t * @param {module:crypto/keyPair~KeyPair} keyPair The client key pair.\n\t * @param {Numeric} securityMode The desired connection security mode.\n\t * @returns {Buffer} A buffer composed of the binary response packet.\n\t */\n\tgenerateServerChallengeResponse: (request, keyPair, securityMode) => {\n\t\t// create a new challenge\n\t\tconst challenge = crypto.randomBytes(sizes.challenge);\n\n\t\t// sign the request challenge\n\t\tconst signedBuffers = [request.challenge, Buffer.of(securityMode)];\n\t\tconst signature = sign(keyPair, Buffer.concat(signedBuffers, sizes.challenge + sizes.securityMode));\n\n\t\t// create the response header\n\t\tconst length = sizes.header + challenge.length + signature.length + keyPair.publicKey.length + sizes.securityMode;\n\t\tconst header = packetHeader.createBuffer(PacketType.serverChallenge, length);\n\n\t\t// merge all buffers\n\t\tconst buffers = [\n\t\t\theader,\n\t\t\tchallenge,\n\t\t\tBuffer.from(signature.buffer),\n\t\t\tBuffer.from(keyPair.publicKey.buffer),\n\t\t\tBuffer.of(securityMode)\n\t\t];\n\t\treturn Buffer.concat(buffers, length);\n\t},\n\n\t/**\n\t * Verifies a server's response to a challenge.\n\t * @param {object} response The parsed client challenge response.\n\t * @param {module:crypto/keyPair~PublicKey} publicKey The server public key.\n\t * @param {Uint8Array} challenge The challenge presented to the server.\n\t * @returns {boolean} true if the response can be verified, false otherwise.\n\t */\n\tverifyClientChallengeResponse: (response, publicKey, challenge) => verify(publicKey, challenge, response.signature),\n\n\t// endregion\n\n\t// region verify client challenges\n\n\t/**\n\t * Generates a random server challenge that is sent to a client.\n\t * @returns {Buffer} A buffer composed of the binary request packet.\n\t */\n\tgenerateServerChallengeRequest: () => {\n\t\t// create a new challenge\n\t\tconst challenge = crypto.randomBytes(sizes.challenge);\n\n\t\t// create the request header\n\t\tconst length = sizes.header + sizes.challenge;\n\t\tconst header = packetHeader.createBuffer(PacketType.serverChallenge, length);\n\n\t\t// merge all buffers\n\t\tconst buffers = [header, challenge];\n\t\treturn Buffer.concat(buffers, length);\n\t},\n\n\t/**\n\t * Verifies a client's response to a challenge.\n\t * @param {object} response The parsed server challenge response.\n\t * @param {Uint8Array} challenge The challenge presented to the client.\n\t * @returns {boolean} true if the response can be verified, false otherwise.\n\t */\n\tverifyServerChallengeResponse: (response, challenge) => {\n\t\tconst signedBuffers = [challenge, Buffer.of(response.securityMode)];\n\t\treturn verify(response.publicKey, Buffer.concat(signedBuffers, sizes.challenge + sizes.securityMode), response.signature);\n\t},\n\n\t/**\n\t * Generates a server response to a client challenge.\n\t * @param {object} request The parsed client challenge request.\n\t * @param {module:crypto/keyPair~KeyPair} keyPair The server key pair.\n\t * @returns {Buffer} A buffer composed of the binary response packet.\n\t */\n\tgenerateClientChallengeResponse: (request, keyPair) => {\n\t\t// sign the request challenge\n\t\tconst signature = sign(keyPair, request.challenge);\n\n\t\t// create the response header\n\t\tconst length = sizes.header + signature.length;\n\t\tconst header = packetHeader.createBuffer(PacketType.clientChallenge, length);\n\n\t\t// merge all buffers\n\t\tconst buffers = [header, Buffer.from(signature.buffer)];\n\t\treturn Buffer.concat(buffers, length);\n\t}\n\n\t// endregion\n};\n\nmodule.exports = challengeModule;\n"]}