{"version":3,"sources":["../../src/modelBinary/ModelCodecBuilder.js"],"names":["blockHeaderCodec","require","transactionCodec","verifiableEntityCodec","SerializedSizeCalculator","constants","sizes","blockHeader","transactionHeader","isBlockType","entityType","findCodecs","codecs","codec","Error","createThrowawayConsumingCodec","deserialize","parser","buffer","size","deserializeTransactions","txCodecs","transactions","remainingBytes","transactionSize","uint32","entity","type","push","forEach","Object","assign","ModelCodecBuilder","supports","undefined","options","shift","shouldParseBlockTransactions","skipBlockTransactions","extraSize","serialize","serializer","sizeCalculator","writeUint32","module","exports"],"mappings":"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","file":"ModelCodecBuilder.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/** @module modelBinary/ModelCodecBuilder */\nconst blockHeaderCodec = require('./blockHeaderCodec');\nconst transactionCodec = require('./transactionCodec');\nconst verifiableEntityCodec = require('./verifiableEntityCodec');\nconst SerializedSizeCalculator = require('../serializer/SerializedSizeCalculator');\n\nconst constants = {\n\tsizes: {\n\t\tblockHeader: 192,\n\t\ttransactionHeader: 120\n\t}\n};\n\nconst isBlockType = entityType => 0 !== (0x8000 & entityType);\n\nconst findCodecs = (entityType, codecs) => {\n\tif (isBlockType(entityType))\n\t\treturn [verifiableEntityCodec, blockHeaderCodec];\n\n\tconst codec = codecs[entityType];\n\tif (!codec)\n\t\tthrow Error(`no codec registered for '${entityType}'`);\n\n\treturn [verifiableEntityCodec, transactionCodec, codec];\n};\n\nconst createThrowawayConsumingCodec = size => ({\n\tdeserialize: parser => { parser.buffer(size); }\n});\n\nconst deserializeTransactions = (parser, size, txCodecs) => {\n\tconst transactions = [];\n\tlet remainingBytes = size;\n\twhile (0 < remainingBytes) {\n\t\tconst transactionSize = parser.uint32();\n\t\tif (transactionSize < constants.sizes.transactionHeader)\n\t\t\tthrow Error('transaction must contain complete transaction header');\n\n\t\tremainingBytes -= transactionSize;\n\t\tconst entity = verifiableEntityCodec.deserialize(parser);\n\n\t\t// allow unknown txes to be deserialized as basic txes\n\t\tconst codecs = [transactionCodec];\n\t\tif (txCodecs[entity.type])\n\t\t\tcodecs.push(txCodecs[entity.type]);\n\t\telse\n\t\t\tcodecs.push(createThrowawayConsumingCodec(transactionSize - constants.sizes.transactionHeader));\n\n\t\tcodecs.forEach(codec => {\n\t\t\tObject.assign(entity, codec.deserialize(parser, transactionSize, txCodecs));\n\t\t});\n\n\t\ttransactions.push(entity);\n\t}\n\n\treturn transactions;\n};\n\n/**\n * Builder for creating an aggregate model codec.\n */\nclass ModelCodecBuilder {\n\t/**\n\t * Creates a model codec builder.\n\t */\n\tconstructor() {\n\t\tthis.codecs = [];\n\t}\n\n\t/**\n\t * Adds support for a typed transaction.\n\t * @param {module:model/EntityType} type The transaction type.\n\t * @param {object} codec The transaction codec.\n\t */\n\taddTransactionSupport(type, codec) {\n\t\tif (isBlockType(type) || this.codecs[type])\n\t\t\tthrow Error(`codec already registered for '${type}'`);\n\n\t\tthis.codecs[type] = codec;\n\t}\n\n\t/**\n\t * Builds and returns an appropriate aggregate model codec.\n\t * @returns {module:modelBinary/AggregateModelCodec} The aggregate model codec.\n\t */\n\tbuild() {\n\t\tconst txCodecs = this.codecs;\n\t\treturn {\n\t\t\tsupports(type) {\n\t\t\t\treturn isBlockType(type) || undefined !== txCodecs[type];\n\t\t\t},\n\n\t\t\tdeserialize: (parser, options) => {\n\t\t\t\t// get codecs for the current entity (and ignore the verifiableEntity codec)\n\t\t\t\tconst size = parser.uint32();\n\t\t\t\tconst entity = verifiableEntityCodec.deserialize(parser);\n\t\t\t\tconst codecs = findCodecs(entity.type, txCodecs);\n\t\t\t\tcodecs.shift();\n\n\t\t\t\tcodecs.forEach(codec => {\n\t\t\t\t\tObject.assign(entity, codec.deserialize(parser, size, txCodecs));\n\t\t\t\t});\n\n\t\t\t\t// if it's a block with transactions, also deserialize them\n\t\t\t\tconst shouldParseBlockTransactions = !(options && options.skipBlockTransactions);\n\t\t\t\tif (shouldParseBlockTransactions && isBlockType(entity.type) && constants.sizes.blockHeader !== size) {\n\t\t\t\t\tconst extraSize = size - constants.sizes.blockHeader;\n\t\t\t\t\tif (0 > extraSize)\n\t\t\t\t\t\tthrow Error('block must contain complete block header');\n\n\t\t\t\t\tentity.transactions = deserializeTransactions(parser, extraSize, txCodecs);\n\t\t\t\t}\n\n\t\t\t\treturn entity;\n\t\t\t},\n\n\t\t\tserialize: (entity, serializer) => {\n\t\t\t\tconst codecs = findCodecs(entity.type, txCodecs);\n\n\t\t\t\tconst sizeCalculator = new SerializedSizeCalculator();\n\t\t\t\tcodecs.forEach(codec => {\n\t\t\t\t\tcodec.serialize(entity, sizeCalculator, txCodecs);\n\t\t\t\t});\n\n\t\t\t\tserializer.writeUint32(sizeCalculator.size() + 4); // include size of size field itself\n\t\t\t\tcodecs.forEach(codec => {\n\t\t\t\t\tcodec.serialize(entity, serializer, txCodecs);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = ModelCodecBuilder;\n"]}