'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module modelBinary/ModelCodecBuilder */
var blockHeaderCodec = require('./blockHeaderCodec');
var transactionCodec = require('./transactionCodec');
var verifiableEntityCodec = require('./verifiableEntityCodec');
var SerializedSizeCalculator = require('../serializer/SerializedSizeCalculator');

var constants = {
	sizes: {
		blockHeader: 192,
		transactionHeader: 120
	}
};

var isBlockType = function isBlockType(entityType) {
	return 0 !== (0x8000 & entityType);
};

var findCodecs = function findCodecs(entityType, codecs) {
	if (isBlockType(entityType)) return [verifiableEntityCodec, blockHeaderCodec];

	var codec = codecs[entityType];
	if (!codec) throw Error('no codec registered for \'' + entityType + '\'');

	return [verifiableEntityCodec, transactionCodec, codec];
};

var createThrowawayConsumingCodec = function createThrowawayConsumingCodec(size) {
	return {
		deserialize: function deserialize(parser) {
			parser.buffer(size);
		}
	};
};

var deserializeTransactions = function deserializeTransactions(parser, size, txCodecs) {
	var transactions = [];
	var remainingBytes = size;

	var _loop = function _loop() {
		var transactionSize = parser.uint32();
		if (transactionSize < constants.sizes.transactionHeader) throw Error('transaction must contain complete transaction header');

		remainingBytes -= transactionSize;
		var entity = verifiableEntityCodec.deserialize(parser);

		// allow unknown txes to be deserialized as basic txes
		var codecs = [transactionCodec];
		if (txCodecs[entity.type]) codecs.push(txCodecs[entity.type]);else codecs.push(createThrowawayConsumingCodec(transactionSize - constants.sizes.transactionHeader));

		codecs.forEach(function (codec) {
			Object.assign(entity, codec.deserialize(parser, transactionSize, txCodecs));
		});

		transactions.push(entity);
	};

	while (0 < remainingBytes) {
		_loop();
	}

	return transactions;
};

/**
 * Builder for creating an aggregate model codec.
 */

var ModelCodecBuilder = function () {
	/**
  * Creates a model codec builder.
  */
	function ModelCodecBuilder() {
		_classCallCheck(this, ModelCodecBuilder);

		this.codecs = [];
	}

	/**
  * Adds support for a typed transaction.
  * @param {module:model/EntityType} type The transaction type.
  * @param {object} codec The transaction codec.
  */


	_createClass(ModelCodecBuilder, [{
		key: 'addTransactionSupport',
		value: function addTransactionSupport(type, codec) {
			if (isBlockType(type) || this.codecs[type]) throw Error('codec already registered for \'' + type + '\'');

			this.codecs[type] = codec;
		}

		/**
   * Builds and returns an appropriate aggregate model codec.
   * @returns {module:modelBinary/AggregateModelCodec} The aggregate model codec.
   */

	}, {
		key: 'build',
		value: function build() {
			var txCodecs = this.codecs;
			return {
				supports: function supports(type) {
					return isBlockType(type) || undefined !== txCodecs[type];
				},


				deserialize: function deserialize(parser, options) {
					// get codecs for the current entity (and ignore the verifiableEntity codec)
					var size = parser.uint32();
					var entity = verifiableEntityCodec.deserialize(parser);
					var codecs = findCodecs(entity.type, txCodecs);
					codecs.shift();

					codecs.forEach(function (codec) {
						Object.assign(entity, codec.deserialize(parser, size, txCodecs));
					});

					// if it's a block with transactions, also deserialize them
					var shouldParseBlockTransactions = !(options && options.skipBlockTransactions);
					if (shouldParseBlockTransactions && isBlockType(entity.type) && constants.sizes.blockHeader !== size) {
						var extraSize = size - constants.sizes.blockHeader;
						if (0 > extraSize) throw Error('block must contain complete block header');

						entity.transactions = deserializeTransactions(parser, extraSize, txCodecs);
					}

					return entity;
				},

				serialize: function serialize(entity, serializer) {
					var codecs = findCodecs(entity.type, txCodecs);

					var sizeCalculator = new SerializedSizeCalculator();
					codecs.forEach(function (codec) {
						codec.serialize(entity, sizeCalculator, txCodecs);
					});

					serializer.writeUint32(sizeCalculator.size() + 4); // include size of size field itself
					codecs.forEach(function (codec) {
						codec.serialize(entity, serializer, txCodecs);
					});
				}
			};
		}
	}]);

	return ModelCodecBuilder;
}();

module.exports = ModelCodecBuilder;
//# sourceMappingURL=ModelCodecBuilder.js.map