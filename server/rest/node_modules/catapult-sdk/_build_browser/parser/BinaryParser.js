'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module parser/BinaryParser */

var BufferContainer = function () {
	function BufferContainer() {
		_classCallCheck(this, BufferContainer);

		this.offset = 0;
		this.buffers = [];
		this.numUnprocessedBytes = 0;
	}

	_createClass(BufferContainer, [{
		key: 'current',
		value: function current() {
			return this.buffers[0];
		}
	}, {
		key: 'push',
		value: function push(buffer) {
			if (!Buffer.isBuffer(buffer)) throw Error('BinaryParser only supports aggregating NodeJS Buffer objects');

			if (0 === buffer.length) return;

			this.buffers.push(buffer);
			this.numUnprocessedBytes += buffer.length;
		}
	}, {
		key: 'consume',
		value: function consume(size) {
			this.offset += size;
			this.numUnprocessedBytes -= size;

			if (this.offset === this.current().length) {
				this.offset = 0;
				this.buffers.shift();
			}
		}
	}, {
		key: 'requireUnprocessed',
		value: function requireUnprocessed(size) {
			if (this.numUnprocessedBytes < size) throw Error('insufficient unprocessed data (' + size + ' bytes required, ' + this.numUnprocessedBytes + ' bytes available)');
		}
	}, {
		key: 'nextByte',
		value: function nextByte() {
			this.requireUnprocessed(1);

			var buffer = this.current();
			var byte = buffer[this.offset];
			this.consume(1);
			return byte;
		}
	}, {
		key: 'nextInteger',
		value: function nextInteger(size) {
			this.requireUnprocessed(size);

			var value = 0;
			for (var i = 0; i < size; ++i) {
				value |= this.nextByte() << i * 8;
			}return value >>> 0;
		}
	}, {
		key: 'nextBuffer',
		value: function nextBuffer(size) {
			this.requireUnprocessed(size);

			return this.nextBufferInPlace(size) || this.nextBufferOutOfPlace(size);
		}
	}, {
		key: 'nextBufferInPlace',
		value: function nextBufferInPlace(size) {
			var buffer = this.current();
			if (buffer.length - this.offset < size) return undefined;

			var result = buffer.slice(this.offset, this.offset + size);
			this.consume(size);
			return result;
		}
	}, {
		key: 'nextBufferOutOfPlace',
		value: function nextBufferOutOfPlace(size) {
			// the requested buffer spans multiple buffers, so copy into a new buffer
			var result = Buffer.allocUnsafe(size);
			for (var i = 0; i < size; ++i) {
				result[i] = this.nextByte();
			}return result;
		}
	}, {
		key: 'size',
		value: function size() {
			return this.numUnprocessedBytes;
		}
	}]);

	return BufferContainer;
}();

/**
 * Accepts and buffers binary data and provides an interface for reading from it.
 */


var BinaryParser = function () {
	/**
  * Creates a binary parser.
  */
	function BinaryParser() {
		_classCallCheck(this, BinaryParser);

		this.buffers = new BufferContainer();
	}

	/**
  * Accepts a binary buffer and appends it to the end of the working buffer.
  * @param {Buffer} buffer The binary buffer.
  */


	_createClass(BinaryParser, [{
		key: 'push',
		value: function push(buffer) {
			this.buffers.push(buffer);
		}

		/**
   * Reads a uint8 from the working buffer.
   * @returns {numeric} The read uint8.
   */

	}, {
		key: 'uint8',
		value: function uint8() {
			return this.buffers.nextByte();
		}

		/**
   * Reads a uint16 from the working buffer.
   * @returns {numeric} The read uint16.
   */

	}, {
		key: 'uint16',
		value: function uint16() {
			return this.buffers.nextInteger(2);
		}

		/**
   * Reads a uint32 from the working buffer.
   * @returns {numeric} The read uint32.
   */

	}, {
		key: 'uint32',
		value: function uint32() {
			return this.buffers.nextInteger(4);
		}

		/**
   * Reads a uint64 from the working buffer.
   * @returns {module:utils/uint64~uint64} The read uint64.
   */

	}, {
		key: 'uint64',
		value: function uint64() {
			this.buffers.requireUnprocessed(8);
			return [this.uint32(), this.uint32()];
		}

		/**
   * Reads a specific number of bytes from the working buffer.
   * @param {numeric} size The number of bytes to read.
   * @returns {Buffer} The read bytes.
   */

	}, {
		key: 'buffer',
		value: function buffer(size) {
			return this.buffers.nextBuffer(size);
		}

		/**
   * Gets the number of unprocessed bytes remaining in the working buffer.
   * @returns {numeric} The number of unprocessed bytes.
   */

	}, {
		key: 'numUnprocessedBytes',
		value: function numUnprocessedBytes() {
			return this.buffers.size();
		}
	}]);

	return BinaryParser;
}();

module.exports = BinaryParser;
//# sourceMappingURL=BinaryParser.js.map