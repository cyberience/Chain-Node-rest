{"version":3,"sources":["../../src/parser/BinaryParser.js"],"names":["BufferContainer","offset","buffers","numUnprocessedBytes","buffer","Buffer","isBuffer","Error","length","push","size","current","shift","requireUnprocessed","byte","consume","value","i","nextByte","nextBufferInPlace","nextBufferOutOfPlace","undefined","result","slice","allocUnsafe","BinaryParser","nextInteger","uint32","nextBuffer","module","exports"],"mappings":"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","file":"BinaryParser.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/** @module parser/BinaryParser */\n\nclass BufferContainer {\n\tconstructor() {\n\t\tthis.offset = 0;\n\t\tthis.buffers = [];\n\t\tthis.numUnprocessedBytes = 0;\n\t}\n\n\tcurrent() {\n\t\treturn this.buffers[0];\n\t}\n\n\tpush(buffer) {\n\t\tif (!Buffer.isBuffer(buffer))\n\t\t\tthrow Error('BinaryParser only supports aggregating NodeJS Buffer objects');\n\n\t\tif (0 === buffer.length)\n\t\t\treturn;\n\n\t\tthis.buffers.push(buffer);\n\t\tthis.numUnprocessedBytes += buffer.length;\n\t}\n\n\tconsume(size) {\n\t\tthis.offset += size;\n\t\tthis.numUnprocessedBytes -= size;\n\n\t\tif (this.offset === this.current().length) {\n\t\t\tthis.offset = 0;\n\t\t\tthis.buffers.shift();\n\t\t}\n\t}\n\n\trequireUnprocessed(size) {\n\t\tif (this.numUnprocessedBytes < size)\n\t\t\tthrow Error(`insufficient unprocessed data (${size} bytes required, ${this.numUnprocessedBytes} bytes available)`);\n\t}\n\n\tnextByte() {\n\t\tthis.requireUnprocessed(1);\n\n\t\tconst buffer = this.current();\n\t\tconst byte = buffer[this.offset];\n\t\tthis.consume(1);\n\t\treturn byte;\n\t}\n\n\tnextInteger(size) {\n\t\tthis.requireUnprocessed(size);\n\n\t\tlet value = 0;\n\t\tfor (let i = 0; i < size; ++i)\n\t\t\tvalue |= this.nextByte() << (i * 8);\n\n\t\treturn value >>> 0;\n\t}\n\n\tnextBuffer(size) {\n\t\tthis.requireUnprocessed(size);\n\n\t\treturn this.nextBufferInPlace(size) || this.nextBufferOutOfPlace(size);\n\t}\n\n\tnextBufferInPlace(size) {\n\t\tconst buffer = this.current();\n\t\tif (buffer.length - this.offset < size)\n\t\t\treturn undefined;\n\n\t\tconst result = buffer.slice(this.offset, this.offset + size);\n\t\tthis.consume(size);\n\t\treturn result;\n\t}\n\n\tnextBufferOutOfPlace(size) {\n\t\t// the requested buffer spans multiple buffers, so copy into a new buffer\n\t\tconst result = Buffer.allocUnsafe(size);\n\t\tfor (let i = 0; i < size; ++i)\n\t\t\tresult[i] = this.nextByte();\n\n\t\treturn result;\n\t}\n\n\tsize() {\n\t\treturn this.numUnprocessedBytes;\n\t}\n}\n\n/**\n * Accepts and buffers binary data and provides an interface for reading from it.\n */\nclass BinaryParser {\n\t/**\n\t * Creates a binary parser.\n\t */\n\tconstructor() {\n\t\tthis.buffers = new BufferContainer();\n\t}\n\n\t/**\n\t * Accepts a binary buffer and appends it to the end of the working buffer.\n\t * @param {Buffer} buffer The binary buffer.\n\t */\n\tpush(buffer) {\n\t\tthis.buffers.push(buffer);\n\t}\n\n\t/**\n\t * Reads a uint8 from the working buffer.\n\t * @returns {numeric} The read uint8.\n\t */\n\tuint8() {\n\t\treturn this.buffers.nextByte();\n\t}\n\n\t/**\n\t * Reads a uint16 from the working buffer.\n\t * @returns {numeric} The read uint16.\n\t */\n\tuint16() {\n\t\treturn this.buffers.nextInteger(2);\n\t}\n\n\t/**\n\t * Reads a uint32 from the working buffer.\n\t * @returns {numeric} The read uint32.\n\t */\n\tuint32() {\n\t\treturn this.buffers.nextInteger(4);\n\t}\n\n\t/**\n\t * Reads a uint64 from the working buffer.\n\t * @returns {module:utils/uint64~uint64} The read uint64.\n\t */\n\tuint64() {\n\t\tthis.buffers.requireUnprocessed(8);\n\t\treturn [this.uint32(), this.uint32()];\n\t}\n\n\t/**\n\t * Reads a specific number of bytes from the working buffer.\n\t * @param {numeric} size The number of bytes to read.\n\t * @returns {Buffer} The read bytes.\n\t */\n\tbuffer(size) {\n\t\treturn this.buffers.nextBuffer(size);\n\t}\n\n\t/**\n\t * Gets the number of unprocessed bytes remaining in the working buffer.\n\t * @returns {numeric} The number of unprocessed bytes.\n\t */\n\tnumUnprocessedBytes() {\n\t\treturn this.buffers.size();\n\t}\n}\n\nmodule.exports = BinaryParser;\n"]}