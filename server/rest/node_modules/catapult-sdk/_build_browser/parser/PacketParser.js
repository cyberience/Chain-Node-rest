'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module parser/PacketParser */
var EventEmitter = require('events');
var BinaryParser = require('./BinaryParser');

var Packet_Header_Size = 8;

var PacketParserImpl = function () {
	function PacketParserImpl() {
		_classCallCheck(this, PacketParserImpl);

		this.parser = new BinaryParser();
		this.packetHeader = undefined;
		this.emitter = new EventEmitter();
	}

	_createClass(PacketParserImpl, [{
		key: 'push',
		value: function push(buffer) {
			this.parser.push(buffer);

			// note: processHeader will process at most one header when called consecutively
			do {
				this.processHeader();
				this.processBody();
			} while (this.processHeader());
		}
	}, {
		key: 'processHeader',
		value: function processHeader() {
			if (undefined !== this.packetHeader || this.parser.numUnprocessedBytes() < Packet_Header_Size) return false;

			var size = this.parser.uint32();
			var type = this.parser.uint32();

			if (size < Packet_Header_Size) throw Error('packet size (' + size + ') cannot be less than packet header size');

			this.packetHeader = { size: size, type: type };
			return true;
		}
	}, {
		key: 'processBody',
		value: function processBody() {
			if (undefined === this.packetHeader || this.parser.numUnprocessedBytes() < this.packetHeader.size - Packet_Header_Size) return false;

			this.raisePacketEvent();
			this.packetHeader = undefined;
			return true;
		}
	}, {
		key: 'raisePacketEvent',
		value: function raisePacketEvent() {
			// consume the entire payload
			var payload = this.packetHeader.size > Packet_Header_Size ? this.parser.buffer(this.packetHeader.size - Packet_Header_Size) : Buffer.alloc(0);

			this.emitter.emit('packet', { type: this.packetHeader.type, size: this.packetHeader.size, payload: payload });
		}
	}]);

	return PacketParserImpl;
}();

/**
 * A raw packet composed of header information and a payload.
 * @typedef {object} RawPacket
 * @property {numeric} type The packet type.
 * @property {numeric} size The packet size.
 * @property {Buffer} payload The packet payload.
 */

/**
 * Accepts and buffers binary data and emits events when full packets have been received.
 */


var PacketParser = function () {
	/**
  * Creates a packet parser.
  */
	function PacketParser() {
		_classCallCheck(this, PacketParser);

		this.impl = new PacketParserImpl();
	}

	/**
  * Accepts a binary buffer and appends it to the end of the working buffer.
  * @param {Buffer} buffer The binary buffer.
  */


	_createClass(PacketParser, [{
		key: 'push',
		value: function push(buffer) {
			this.impl.push(buffer);
		}

		/**
   * Subscribes a handler to receive notifications when full packets have been received.
   * @param {Function} handler The handler function that is called with a {@link module:parser/PacketParser~RawPacket}.
   */

	}, {
		key: 'onPacket',
		value: function onPacket(handler) {
			this.impl.emitter.on('packet', handler);
		}
	}]);

	return PacketParser;
}();

module.exports = PacketParser;
//# sourceMappingURL=PacketParser.js.map