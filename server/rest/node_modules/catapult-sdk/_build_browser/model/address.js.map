{"version":3,"sources":["../../src/model/address.js"],"names":["require","sha3_256","Ripemd160","arrayUtils","base32","convert","constants","sizes","ripemd160","addressDecoded","addressEncoded","key","checksum","address","stringToAddress","encoded","length","Error","decode","addressToString","decoded","uint8ToHex","encode","publicKeyToAddress","publicKey","networkIdentifier","publicKeyHash","arrayBuffer","ripemdHash","update","Buffer","from","digest","decodedAddress","Uint8Array","copy","hash","subarray","uint8View","isValidAddress","create","checksumBegin","deepEqual","isValidEncodedAddress","err","module","exports"],"mappings":"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","file":"address.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst { sha3_256 } = require('js-sha3');\nconst Ripemd160 = require('ripemd160');\nconst arrayUtils = require('../utils/arrayUtils');\nconst base32 = require('../utils/base32');\nconst convert = require('../utils/convert');\n\nconst constants = {\n\tsizes: {\n\t\tripemd160: 20,\n\t\taddressDecoded: 25,\n\t\taddressEncoded: 40,\n\t\tkey: 32,\n\t\tchecksum: 4\n\t}\n};\n\n/** @exports model/address */\nconst address = {\n\t/**\n\t * Converts an encoded address string to a decoded address.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {Uint8Array} The decoded address corresponding to the input.\n\t */\n\tstringToAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\tthrow Error(`${encoded} does not represent a valid encoded address`);\n\n\t\treturn base32.decode(encoded);\n\t},\n\n\t/**\n\t * Converts a decoded address to an encoded address string.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {string} The encoded address string corresponding to the input.\n\t */\n\taddressToString: decoded => {\n\t\tif (constants.sizes.addressDecoded !== decoded.length)\n\t\t\tthrow Error(`${convert.uint8ToHex(decoded)} does not represent a valid decoded address`);\n\n\t\treturn base32.encode(decoded);\n\t},\n\n\t/**\n\t * Converts a public key to a decoded address for a specific network.\n\t * @param {module:crypto/keyPair~PublicKey} publicKey The public key.\n\t * @param {numeric} networkIdentifier The network identifier.\n\t * @returns {Uint8Array} The decoded address corresponding to the inputs.\n\t */\n\tpublicKeyToAddress: (publicKey, networkIdentifier) => {\n\t\t// step 1: sha3 hash of the public key\n\t\tconst publicKeyHash = sha3_256.arrayBuffer(publicKey);\n\n\t\t// step 2: ripemd160 hash of (1)\n\t\tconst ripemdHash = new Ripemd160().update(Buffer.from(publicKeyHash)).digest();\n\n\t\t// step 3: add network identifier byte in front of (2)\n\t\tconst decodedAddress = new Uint8Array(constants.sizes.addressDecoded);\n\t\tdecodedAddress[0] = networkIdentifier;\n\t\tarrayUtils.copy(decodedAddress, ripemdHash, constants.sizes.ripemd160, 1);\n\n\t\t// step 4: concatenate (3) and the checksum of (3)\n\t\tconst hash = sha3_256.arrayBuffer(decodedAddress.subarray(0, constants.sizes.ripemd160 + 1));\n\t\tarrayUtils.copy(decodedAddress, arrayUtils.uint8View(hash), constants.sizes.checksum, constants.sizes.ripemd160 + 1);\n\n\t\treturn decodedAddress;\n\t},\n\n\t/**\n\t * Determines the validity of a decoded address.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {boolean} true if the decoded address is valid, false otherwise.\n\t */\n\tisValidAddress: decoded => {\n\t\tconst hash = sha3_256.create();\n\t\tconst checksumBegin = constants.sizes.addressDecoded - constants.sizes.checksum;\n\t\thash.update(decoded.subarray(0, checksumBegin));\n\t\tconst checksum = new Uint8Array(constants.sizes.checksum);\n\t\tarrayUtils.copy(checksum, arrayUtils.uint8View(hash.arrayBuffer()), constants.sizes.checksum);\n\t\treturn arrayUtils.deepEqual(checksum, decoded.subarray(checksumBegin));\n\t},\n\n\t/**\n\t * Determines the validity of an encoded address string.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {boolean} true if the encoded address string is valid, false otherwise.\n\t */\n\tisValidEncodedAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\treturn false;\n\n\t\ttry {\n\t\t\tconst decoded = address.stringToAddress(encoded);\n\t\t\treturn address.isValidAddress(decoded);\n\t\t} catch (err) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nmodule.exports = address;\n"]}