'use strict';

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

var _require = require('js-sha3'),
    sha3_256 = _require.sha3_256;

var constants = {
	namespace_base_id: [0, 0],
	namespace_max_depth: 3,
	name_pattern: /^[a-z0-9][a-z0-9-_]*$/
};

var generateId = function generateId(parentId, name) {
	var hash = sha3_256.create();
	hash.update(Uint32Array.from(parentId).buffer);
	hash.update(name);
	var result = new Uint32Array(hash.arrayBuffer());
	return [result[0], result[1]];
};

var throwInvalidFqn = function throwInvalidFqn(reason, name) {
	throw Error('fully qualified id is invalid due to ' + reason + ' (' + name + ')');
};

var findMosaicSeparatorIndex = function findMosaicSeparatorIndex(name) {
	var mosaicSeparatorIndex = name.lastIndexOf(':');
	if (0 > mosaicSeparatorIndex) throwInvalidFqn('missing mosaic', name);

	if (0 === mosaicSeparatorIndex) throwInvalidFqn('empty part', name);

	return mosaicSeparatorIndex;
};

var extractPartName = function extractPartName(name, start, size) {
	if (0 === size) throwInvalidFqn('empty part', name);

	var partName = name.substr(start, size);
	if (!constants.name_pattern.test(partName)) throwInvalidFqn('invalid part name [' + partName + ']', name);

	return partName;
};

var append = function append(path, id, name) {
	if (constants.namespace_max_depth === path.length) throwInvalidFqn('too many parts', name);

	path.push(id);
};

var split = function split(name, processor) {
	var start = 0;
	for (var index = 0; index < name.length; ++index) {
		if ('.' === name[index]) {
			processor(start, index - start);
			start = index + 1;
		}
	}

	return start;
};

/** @exports model/idGenerator */
var idGenerator = {
	/**
  * Generates a mosaic id given a unified mosaic name.
  * @param {string} name The unified mosaic name.
  * @returns {module:utils/uint64~uint64} The mosaic id.
  */
	generateMosaicId: function generateMosaicId(name) {
		if (0 >= name.length) throwInvalidFqn('having zero length', name);

		var mosaicSeparatorIndex = findMosaicSeparatorIndex(name);

		var namespaceName = name.substr(0, mosaicSeparatorIndex);
		var namespacePath = idGenerator.generateNamespacePath(namespaceName);
		var namespaceId = namespacePath[namespacePath.length - 1];

		return generateId(namespaceId, extractPartName(name, mosaicSeparatorIndex + 1, name.length - mosaicSeparatorIndex - 1));
	},

	/**
  * Parses a unified namespace name into a path.
  * @param {string} name The unified namespace name.
  * @returns {array<module:utils/uint64~uint64>} The namespace path.
  */
	generateNamespacePath: function generateNamespacePath(name) {
		if (0 >= name.length) throwInvalidFqn('having zero length', name);

		var namespaceId = constants.namespace_base_id;
		var path = [];
		var start = split(name, function (substringStart, size) {
			namespaceId = generateId(namespaceId, extractPartName(name, substringStart, size));
			append(path, namespaceId, name);
		});

		namespaceId = generateId(namespaceId, extractPartName(name, start, name.length - start));
		append(path, namespaceId, name);
		return path;
	}
};

module.exports = idGenerator;
//# sourceMappingURL=idGenerator.js.map