{"version":3,"sources":["../../src/crypto/merkleAuditProof.js"],"names":["arrayUtils","require","NodePositionEnum","Object","freeze","left","right","HashNotFoundError","Error","InvalidTree","evenify","number","indexOfLeafWithHash","hash","tree","nodes","slice","numberOfTransactions","findIndex","deepEqual","element","siblingOf","nodeIndex","position","index","buildAuditPath","layerStart","currentLayerCount","layerSubindexOfHash","auditPath","sibling","siblingPathNode","push","Math","floor","module","exports"],"mappings":";;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AAoBA,IAAMA,aAAaC,QAAQ,qBAAR,CAAnB;;AAEA,IAAMC,mBAAmBC,OAAOC,MAAP,CAAc;AACtCC,OAAM,CADgC;AAEtCC,QAAO;AAF+B,CAAd,CAAzB;;IAKMC,iB;;;;;;;;;;EAA0BC,K;;IAC1BC,W;;;;;;;;;;EAAoBD,K;;AAE1B,IAAME,UAAU,SAAVA,OAAU;AAAA,QAAWC,SAAS,CAAT,GAAaA,SAAS,CAAtB,GAA0BA,MAArC;AAAA,CAAhB;;AAEA;;;;;;AAMA,IAAMC,sBAAsB,SAAtBA,mBAAsB,CAACC,IAAD,EAAOC,IAAP;AAAA,QAAgBA,KAAKC,KAAL,CAC1CC,KAD0C,CACpC,CADoC,EACjCN,QAAQI,KAAKG,oBAAb,CADiC,EAE1CC,SAF0C,CAEhC;AAAA,SAAWlB,WAAWmB,SAAX,CAAqBC,OAArB,EAA8BP,IAA9B,CAAX;AAAA,EAFgC,CAAhB;AAAA,CAA5B;;AAIA,IAAMQ,YAAY,SAAZA,SAAY,YAAa;AAC9B,KAAIC,YAAY,CAAhB,EAAmB;AAClB,SAAO;AACNC,aAAUrB,iBAAiBG,IADrB;AAENmB,UAAOF,YAAY;AAFb,GAAP;AAIA;AACD,QAAO;AACNC,YAAUrB,iBAAiBI,KADrB;AAENkB,SAAOF,YAAY;AAFb,EAAP;AAIA,CAXD;;AAaA;;;;;;AAMA,IAAMG,iBAAiB,SAAjBA,cAAiB,CAACZ,IAAD,EAAOC,IAAP,EAAgB;AACtC,KAAI,MAAMA,KAAKG,oBAAf,EACC,MAAM,IAAIR,WAAJ,EAAN;;AAED,KAAIiB,aAAa,CAAjB;AACA,KAAIC,oBAAoBb,KAAKG,oBAA7B;AACA,KAAIW,sBAAsBhB,oBAAoBC,IAApB,EAA0BC,IAA1B,CAA1B;AACA,KAAI,CAAC,CAAD,KAAOc,mBAAX,EACC,MAAM,IAAIrB,iBAAJ,EAAN;;AAED,KAAMsB,YAAY,EAAlB;AACA,QAAO,MAAMF,iBAAb,EAAgC;AAC/BA,sBAAoBjB,QAAQiB,iBAAR,CAApB;AACA,MAAMG,UAAUT,UAAUK,aAAaE,mBAAvB,CAAhB;AACA,MAAMG,kBAAkB;AACvBlB,SAAMC,KAAKC,KAAL,CAAWe,QAAQN,KAAnB,CADiB;AAEvBD,aAAUO,QAAQP;AAFK,GAAxB;AAIAM,YAAUG,IAAV,CAAeD,eAAf;AACAL,gBAAcC,iBAAd;AACAA,uBAAqB,CAArB;AACAC,wBAAsBK,KAAKC,KAAL,CAAWN,sBAAsB,CAAjC,CAAtB;AACA;AACD,QAAOC,SAAP;AACA,CAxBD;;AA0BAM,OAAOC,OAAP,GAAiB;AAChBX,+BADgB;AAEhBf,iBAFgB;AAGhBE,yCAHgB;AAIhBS,qBAJgB;AAKhBnB,mCALgB;AAMhBK,qCANgB;AAOhBE;AAPgB,CAAjB","file":"merkleAuditProof.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst arrayUtils = require('../utils/arrayUtils');\n\nconst NodePositionEnum = Object.freeze({\n\tleft: 1,\n\tright: 2\n});\n\nclass HashNotFoundError extends Error {}\nclass InvalidTree extends Error {}\n\nconst evenify = number => (number % 2 ? number + 1 : number);\n\n/**\n * Returns the index of a transaction hash in a Merkle tree.\n * @param {Uint8Array} hash The transaction hash to look up in the tree.\n * @param {object} tree The Merkle tree object containing the number of transactions and the tree of hashes.\n * @returns {array} The index of the first element in the tree matching the given hash, otherwise -1 is returned.\n */\nconst indexOfLeafWithHash = (hash, tree) => tree.nodes\n\t.slice(0, evenify(tree.numberOfTransactions))\n\t.findIndex(element => arrayUtils.deepEqual(element, hash));\n\nconst siblingOf = nodeIndex => {\n\tif (nodeIndex % 2) {\n\t\treturn {\n\t\t\tposition: NodePositionEnum.left,\n\t\t\tindex: nodeIndex - 1\n\t\t};\n\t}\n\treturn {\n\t\tposition: NodePositionEnum.right,\n\t\tindex: nodeIndex + 1\n\t};\n};\n\n/**\n * Given a Merkle tree and a transaction in it, returns the audit path required for a consistency check.\n * @param {Uint8Array} hash The transaction hash for which to build the audit path.\n * @param {object} tree The Merkle tree object containing the number of transactions and the tree of hashes.\n * @returns {array} Array of objects containing the Merkle tree hash, and its relative position (left or right).\n */\nconst buildAuditPath = (hash, tree) => {\n\tif (0 === tree.numberOfTransactions)\n\t\tthrow new InvalidTree();\n\n\tlet layerStart = 0;\n\tlet currentLayerCount = tree.numberOfTransactions;\n\tlet layerSubindexOfHash = indexOfLeafWithHash(hash, tree);\n\tif (-1 === layerSubindexOfHash)\n\t\tthrow new HashNotFoundError();\n\n\tconst auditPath = [];\n\twhile (1 !== currentLayerCount) {\n\t\tcurrentLayerCount = evenify(currentLayerCount);\n\t\tconst sibling = siblingOf(layerStart + layerSubindexOfHash);\n\t\tconst siblingPathNode = {\n\t\t\thash: tree.nodes[sibling.index],\n\t\t\tposition: sibling.position\n\t\t};\n\t\tauditPath.push(siblingPathNode);\n\t\tlayerStart += currentLayerCount;\n\t\tcurrentLayerCount /= 2;\n\t\tlayerSubindexOfHash = Math.floor(layerSubindexOfHash / 2);\n\t}\n\treturn auditPath;\n};\n\nmodule.exports = {\n\tbuildAuditPath,\n\tevenify,\n\tindexOfLeafWithHash,\n\tsiblingOf,\n\tNodePositionEnum,\n\tHashNotFoundError,\n\tInvalidTree\n};\n"]}