'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

var arrayUtils = require('../utils/arrayUtils');

var NodePositionEnum = Object.freeze({
	left: 1,
	right: 2
});

var HashNotFoundError = function (_Error) {
	_inherits(HashNotFoundError, _Error);

	function HashNotFoundError() {
		_classCallCheck(this, HashNotFoundError);

		return _possibleConstructorReturn(this, (HashNotFoundError.__proto__ || Object.getPrototypeOf(HashNotFoundError)).apply(this, arguments));
	}

	return HashNotFoundError;
}(Error);

var InvalidTree = function (_Error2) {
	_inherits(InvalidTree, _Error2);

	function InvalidTree() {
		_classCallCheck(this, InvalidTree);

		return _possibleConstructorReturn(this, (InvalidTree.__proto__ || Object.getPrototypeOf(InvalidTree)).apply(this, arguments));
	}

	return InvalidTree;
}(Error);

var evenify = function evenify(number) {
	return number % 2 ? number + 1 : number;
};

/**
 * Returns the index of a transaction hash in a Merkle tree.
 * @param {Uint8Array} hash The transaction hash to look up in the tree.
 * @param {object} tree The Merkle tree object containing the number of transactions and the tree of hashes.
 * @returns {array} The index of the first element in the tree matching the given hash, otherwise -1 is returned.
 */
var indexOfLeafWithHash = function indexOfLeafWithHash(hash, tree) {
	return tree.nodes.slice(0, evenify(tree.numberOfTransactions)).findIndex(function (element) {
		return arrayUtils.deepEqual(element, hash);
	});
};

var siblingOf = function siblingOf(nodeIndex) {
	if (nodeIndex % 2) {
		return {
			position: NodePositionEnum.left,
			index: nodeIndex - 1
		};
	}
	return {
		position: NodePositionEnum.right,
		index: nodeIndex + 1
	};
};

/**
 * Given a Merkle tree and a transaction in it, returns the audit path required for a consistency check.
 * @param {Uint8Array} hash The transaction hash for which to build the audit path.
 * @param {object} tree The Merkle tree object containing the number of transactions and the tree of hashes.
 * @returns {array} Array of objects containing the Merkle tree hash, and its relative position (left or right).
 */
var buildAuditPath = function buildAuditPath(hash, tree) {
	if (0 === tree.numberOfTransactions) throw new InvalidTree();

	var layerStart = 0;
	var currentLayerCount = tree.numberOfTransactions;
	var layerSubindexOfHash = indexOfLeafWithHash(hash, tree);
	if (-1 === layerSubindexOfHash) throw new HashNotFoundError();

	var auditPath = [];
	while (1 !== currentLayerCount) {
		currentLayerCount = evenify(currentLayerCount);
		var sibling = siblingOf(layerStart + layerSubindexOfHash);
		var siblingPathNode = {
			hash: tree.nodes[sibling.index],
			position: sibling.position
		};
		auditPath.push(siblingPathNode);
		layerStart += currentLayerCount;
		currentLayerCount /= 2;
		layerSubindexOfHash = Math.floor(layerSubindexOfHash / 2);
	}
	return auditPath;
};

module.exports = {
	buildAuditPath: buildAuditPath,
	evenify: evenify,
	indexOfLeafWithHash: indexOfLeafWithHash,
	siblingOf: siblingOf,
	NodePositionEnum: NodePositionEnum,
	HashNotFoundError: HashNotFoundError,
	InvalidTree: InvalidTree
};
//# sourceMappingURL=merkleAuditProof.js.map