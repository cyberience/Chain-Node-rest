{"version":3,"sources":["../../src/utils/schemaFormatter.js"],"names":["SchemaType","require","getSchemaType","definition","type","none","getDefinition","schema","key","resultKey","schemaName","getSchemaName","entity","schemaFormatter","format","entitySchema","schemaDictionary","formattingRules","object","value","array","map","dictionary","result","Object","keys","forEach","rule","module","exports"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA,IAAMA,aAAaC,QAAQ,cAAR,CAAnB;;AAGA;AACA;AACA,IAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,QAAe,aAAa,OAAOC,UAApB,GAAiCA,UAAjC,GAA8CA,WAAWC,IAAX,IAAmBJ,WAAWK,IAA3F;AAAA,CAAtB;;AAEA,IAAMC,gBAAgB,SAAhBA,aAAgB,CAACC,MAAD,EAASC,GAAT,EAAiB;AACtC,KAAML,aAAaI,OAAOC,GAAP,KAAe,EAAlC;AACA,KAAMJ,OAAOF,cAAcC,UAAd,CAAb;;AAEA,QAAO;AACNC,YADM;AAENK,aAAWN,WAAWM,SAAX,IAAwBD,GAF7B;AAGNE,cAAYP,WAAWO;AAHjB,EAAP;AAKA,CATD;;AAWA,IAAMC,gBAAgB,SAAhBA,aAAgB,CAACD,UAAD,EAAaE,MAAb;AAAA,QAAyB,eAAe,OAAOF,UAAtB,GAAmCA,WAAWE,MAAX,CAAnC,GAAwDF,UAAjF;AAAA,CAAtB;;AAEA;;;;;AAKA;;;;;;;;AAQA;AACA,IAAMG,kBAAkB;AACvB;;;;;;;;AAQAC,SAAQ,gBAACF,MAAD,EAASG,YAAT,EAAuBC,gBAAvB,EAAyCC,eAAzC,EAA6D;AACpE;AACAA,kBAAgBjB,WAAWkB,MAA3B,IAAqC,UAACC,KAAD,EAAQL,MAAR;AAAA,UAAmBA,OAAOK,KAAP,CAAnB;AAAA,GAArC;AACAF,kBAAgBjB,WAAWoB,KAA3B,IAAoC,UAACA,KAAD,EAAQN,MAAR;AAAA,UAAmBM,MAAMC,GAAN,CAAU;AAAA,WAASP,OAAOK,KAAP,CAAT;AAAA,IAAV,CAAnB;AAAA,GAApC;AACAF,kBAAgBjB,WAAWsB,UAA3B,IAAyC,UAACA,UAAD,EAAaR,MAAb,EAAwB;AAChE,OAAMS,SAAS,EAAf;AACAC,UAAOC,IAAP,CAAYH,UAAZ,EAAwBI,OAAxB,CAAgC,eAAO;AACtCH,WAAOf,GAAP,IAAcM,OAAOQ,WAAWd,GAAX,CAAP,CAAd;AACA,IAFD;;AAIA,UAAOe,MAAP;AACA,GAPD;;AASA,MAAMA,SAAS,EAAf;AACAC,SAAOC,IAAP,CAAYb,MAAZ,EAAoBc,OAApB,CAA4B,eAAO;AAClC,OAAMvB,aAAaG,cAAcS,YAAd,EAA4BP,GAA5B,CAAnB;AACA,OAAMmB,OAAOV,gBAAgBd,WAAWC,IAA3B,CAAb;AACA,OAAIuB,IAAJ,EAAU;AACT,QAAMjB,aAAaC,cAAcR,WAAWO,UAAzB,EAAqCE,OAAOJ,GAAP,CAArC,CAAnB;AACAe,WAAOpB,WAAWM,SAAlB,IAA+BkB,KAC9Bf,OAAOJ,GAAP,CAD8B,EAE9B,aAAa,OAAOE,UAApB,CAA+B;AAA/B,MACGO,gBAAgBP,UAAhB,CADH,GAEG;AAAA,YAASG,gBAAgBC,MAAhB,CAAuBK,KAAvB,EAA8BH,iBAAiBN,UAAjB,CAA9B,EAA4DM,gBAA5D,EAA8EC,eAA9E,CAAT;AAAA,KAJ2B,CAA/B;AAMA;AACD,GAZD;;AAcA,SAAOM,MAAP;AACA;AAtCsB,CAAxB;;AAyCAK,OAAOC,OAAP,GAAiBhB,eAAjB","file":"schemaFormatter.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/** @module utils/schemaFormatter */\nconst SchemaType = require('./SchemaType');\n\n\n// if 'definition' is a number, it is the type\n// otherwise, it is an object with an optional type property (default type is none)\nconst getSchemaType = definition => ('number' === typeof definition ? definition : definition.type || SchemaType.none);\n\nconst getDefinition = (schema, key) => {\n\tconst definition = schema[key] || {};\n\tconst type = getSchemaType(definition);\n\n\treturn {\n\t\ttype,\n\t\tresultKey: definition.resultKey || key,\n\t\tschemaName: definition.schemaName\n\t};\n};\n\nconst getSchemaName = (schemaName, entity) => ('function' === typeof schemaName ? schemaName(entity) : schemaName);\n\n/**\n * Formatter for formatting a catapult entity.\n * @class EntityFormatter\n */\n\n/**\n * @function format\n * @param {object} entity The entity to format.\n * @returns {object} The formatted entity.\n * @memberof module:utils/schemaFormatter~EntityFormatter\n * @instance\n */\n\n/** @exports utils/schemaFormatter */\nconst schemaFormatter = {\n\t/**\n\t * Formats an entity according to a schema and rules.\n\t * @param {object} entity The entity to format.\n\t * @param {object} entitySchema The schema corresponding to the entity.\n\t * @param {object} schemaDictionary A map of schema names to schemas for looking up component schemas.\n\t * @param {object} formattingRules A map for looking up formatting rules given a schema property type.\n\t * @returns {object} The formatted entity.\n\t */\n\tformat: (entity, entitySchema, schemaDictionary, formattingRules) => {\n\t\t// set object and array rules\n\t\tformattingRules[SchemaType.object] = (value, format) => format(value);\n\t\tformattingRules[SchemaType.array] = (array, format) => array.map(value => format(value));\n\t\tformattingRules[SchemaType.dictionary] = (dictionary, format) => {\n\t\t\tconst result = {};\n\t\t\tObject.keys(dictionary).forEach(key => {\n\t\t\t\tresult[key] = format(dictionary[key]);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst result = {};\n\t\tObject.keys(entity).forEach(key => {\n\t\t\tconst definition = getDefinition(entitySchema, key);\n\t\t\tconst rule = formattingRules[definition.type];\n\t\t\tif (rule) {\n\t\t\t\tconst schemaName = getSchemaName(definition.schemaName, entity[key]);\n\t\t\t\tresult[definition.resultKey] = rule(\n\t\t\t\t\tentity[key],\n\t\t\t\t\t'number' === typeof schemaName // if schemaName is a number, interpret it as a rule id and format child parts as values\n\t\t\t\t\t\t? formattingRules[schemaName]\n\t\t\t\t\t\t: value => schemaFormatter.format(value, schemaDictionary[schemaName], schemaDictionary, formattingRules)\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n};\n\nmodule.exports = schemaFormatter;\n"]}