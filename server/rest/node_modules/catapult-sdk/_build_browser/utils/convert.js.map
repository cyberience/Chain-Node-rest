{"version":3,"sources":["../../src/utils/convert.js"],"names":["charMapping","require","Char_To_Nibble_Map","builder","createBuilder","addRange","map","Char_To_Digit_Map","Nibble_To_Char_Map","tryParseByte","char1","char2","nibble1","nibble2","undefined","convert","toByte","byte","Error","isHexString","input","length","i","hexToUint8","output","Uint8Array","uint8ToHex","s","forEach","tryParseUint","str","value","char","digit","Number","MAX_SAFE_INTEGER","uint8ToUint32","Uint32Array","buffer","uint32ToUint8","uint8ToInt8","int8ToUint8","module","exports"],"mappings":"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","file":"convert.js","sourcesContent":["/*\n * Copyright (c) 2016-present,\n * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.\n *\n * This file is part of Catapult.\n *\n * Catapult is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Catapult is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst charMapping = require('./charMapping');\n\nconst Char_To_Nibble_Map = (() => {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('0', '9', 0);\n\tbuilder.addRange('a', 'f', 10);\n\tbuilder.addRange('A', 'F', 10);\n\treturn builder.map;\n})();\n\nconst Char_To_Digit_Map = (() => {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('0', '9', 0);\n\treturn builder.map;\n})();\n\nconst Nibble_To_Char_Map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\nconst tryParseByte = (char1, char2) => {\n\tconst nibble1 = Char_To_Nibble_Map[char1];\n\tconst nibble2 = Char_To_Nibble_Map[char2];\n\treturn undefined === nibble1 || undefined === nibble2\n\t\t? undefined\n\t\t: (nibble1 << 4) | nibble2;\n};\n\n/** @exports utils/convert */\nconst convert = {\n\t/**\n\t * Decodes two hex characters into a byte.\n\t * @param {string} char1 The first hex digit.\n\t * @param {string} char2 The second hex digit.\n\t * @returns {numeric} The decoded byte.\n\t */\n\ttoByte: (char1, char2) => {\n\t\tconst byte = tryParseByte(char1, char2);\n\t\tif (undefined === byte)\n\t\t\tthrow Error(`unrecognized hex char '${char1}${char2}'`);\n\n\t\treturn byte;\n\t},\n\n\t/**\n\t * Determines whether or not a string is a hex string.\n\t * @param {string} input The string to test.\n\t * @returns {boolean} true if the input is a hex string, false otherwise.\n\t */\n\tisHexString: input => {\n\t\tif (0 !== input.length % 2)\n\t\t\treturn false;\n\n\t\tfor (let i = 0; i < input.length; i += 2) {\n\t\t\tif (undefined === tryParseByte(input[i], input[i + 1]))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Converts a hex string to a uint8 array.\n\t * @param {string} input A hex encoded string.\n\t * @returns {Uint8Array} A uint8 array corresponding to the input.\n\t */\n\thexToUint8: input => {\n\t\tif (0 !== input.length % 2)\n\t\t\tthrow Error(`hex string has unexpected size '${input.length}'`);\n\n\t\tconst output = new Uint8Array(input.length / 2);\n\t\tfor (let i = 0; i < input.length; i += 2)\n\t\t\toutput[i / 2] = convert.toByte(input[i], input[i + 1]);\n\n\t\treturn output;\n\t},\n\n\t/**\n\t * Converts a uint8 array to a hex string.\n\t * @param {Uint8Array} input A uint8 array.\n\t * @returns {string} A hex encoded string corresponding to the input.\n\t */\n\tuint8ToHex: input => {\n\t\tlet s = '';\n\t\tinput.forEach(byte => {\n\t\t\ts += Nibble_To_Char_Map[byte >> 4];\n\t\t\ts += Nibble_To_Char_Map[byte & 0x0F];\n\t\t});\n\n\t\treturn s;\n\t},\n\n\t/**\n\t * Tries to parse a string representing an unsigned integer.\n\t * @param {string} str The string to parse.\n\t * @returns {numeric} The number represented by the input or undefined.\n\t */\n\ttryParseUint: str => {\n\t\tif ('0' === str)\n\t\t\treturn 0;\n\n\t\tlet value = 0;\n\t\tfor (let i = 0; i < str.length; ++i) {\n\t\t\tconst char = str[i];\n\t\t\tconst digit = Char_To_Digit_Map[char];\n\t\t\tif (undefined === digit || (0 === value && 0 === digit))\n\t\t\t\treturn undefined;\n\n\t\t\tvalue *= 10;\n\t\t\tvalue += digit;\n\n\t\t\tif (value > Number.MAX_SAFE_INTEGER)\n\t\t\t\treturn undefined;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Converts a uint8 array to a uint32 array.\n\t * @param {Uint8Array} input A uint8 array.\n\t * @returns {Uint32Array} A uint32 array created from the input.\n\t */\n\tuint8ToUint32: input => new Uint32Array(input.buffer),\n\n\t/**\n\t * Converts a uint32 array to a uint8 array.\n\t * @param {Uint32Array} input A uint32 array.\n\t * @returns {Uint8Array} A uint8 array created from the input.\n\t */\n\tuint32ToUint8: input => new Uint8Array(input.buffer),\n\n\t/** Converts an unsigned byte to a signed byte with the same binary representation.\n\t * @param {Numeric} input An unsigned byte.\n\t * @returns {Numeric} A signed byte with the same binary representation as the input.\n\t */\n\tuint8ToInt8: input => {\n\t\tif (0xFF < input)\n\t\t\tthrow Error(`input '${input}' is out of range`);\n\n\t\treturn input << 24 >> 24;\n\t},\n\n\t/** Converts a signed byte to an unsigned byte with the same binary representation.\n\t * @param {Numeric} input A signed byte.\n\t * @returns {Numeric} An unsigned byte with the same binary representation as the input.\n\t */\n\tint8ToUint8: input => {\n\t\tif (127 < input || -128 > input)\n\t\t\tthrow Error(`input '${input}' is out of range`);\n\n\t\treturn input & 0xFF;\n\t}\n};\n\nmodule.exports = convert;\n"]}