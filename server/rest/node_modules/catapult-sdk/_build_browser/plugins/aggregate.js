'use strict';

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module plugins/aggregate */
var EntityType = require('../model/EntityType');
var ModelType = require('../model/ModelType');
var embeddedEntityCodec = require('../modelBinary/embeddedEntityCodec');
var sizes = require('../modelBinary/sizes');
var SerializedSizeCalculator = require('../serializer/SerializedSizeCalculator');

var constants = { sizes: {} };
Object.assign(constants.sizes, sizes, {
	aggregate: 120 + 4, // size passed into deserialize includes full transaction size (even previously processed parts)
	embedded: 40,
	cosignature: sizes.signer + sizes.signature
});

var createSubTransactionCodec = function createSubTransactionCodec(txCodecs) {
	var getTxCodec = function getTxCodec(type) {
		// unlike in block case (handled by ModelCodecBuilder), don't fallback to unknown transaction type
		var txCodec = txCodecs[type];
		if (!txCodec) throw Error('error unsupported transaction type (' + type + ') in aggregate');

		return txCodec;
	};

	var serializeAll = function serializeAll(transaction, serializer) {
		var codecs = [embeddedEntityCodec, getTxCodec(transaction.type)];
		codecs.forEach(function (codec) {
			codec.serialize(transaction, serializer);
		});
	};

	// notice that the subTxCodec is not conformant and is slightly different from other codecs
	var subTxCodec = {
		size: function size(transaction) {
			var sizeCalculator = new SerializedSizeCalculator();
			serializeAll(transaction, sizeCalculator);
			return sizeCalculator.size() + 4; // include size of size field itself
		},

		deserialize: function deserialize(parser) {
			var size = parser.uint32();
			var entity = embeddedEntityCodec.deserialize(parser);

			var txCodec = getTxCodec(entity.type);
			Object.assign(entity, txCodec.deserialize(parser));
			return { size: size, entity: entity };
		},

		serialize: function serialize(transaction, serializer, size) {
			serializer.writeUint32(size);
			serializeAll(transaction, serializer);
		}
	};

	return subTxCodec;
};

var requireCodecs = function requireCodecs(txCodecs) {
	// this check causes rejection of embedded aggregates because aggregate codec intentionally does not forward tx codecs to
	// sub transaction codecs
	if (undefined === txCodecs) throw Error('aggregate transaction is not embeddable');
};

/**
 * Creates an aggregate plugin.
 * @type {module:plugins/CatapultPlugin}
 */
var aggregatePlugin = {
	registerSchema: function registerSchema(builder) {
		var aggregateSchema = {
			transactions: { type: ModelType.array, schemaName: 'transactionWithMetadata' },
			cosignatures: { type: ModelType.array, schemaName: 'aggregate.cosignature' }
		};

		builder.addTransactionSupport(EntityType.aggregateComplete, aggregateSchema);
		builder.addTransactionSupport(EntityType.aggregateBonded, aggregateSchema);

		builder.addSchema('aggregate.cosignature', {
			signer: ModelType.binary,
			signature: ModelType.binary,
			parentHash: ModelType.binary
		});
	},

	registerCodecs: function registerCodecs(codecBuilder) {
		var aggregateBuilder = {
			deserialize: function deserialize(parser, size, txCodecs) {
				requireCodecs(txCodecs);

				if (size < constants.sizes.aggregate) throw Error('aggregate must contain complete aggregate header');

				var payloadSize = parser.uint32();
				if (size < payloadSize + constants.sizes.aggregate) throw Error('aggregate must contain complete payload');

				// 1. deserialize transactions
				var transaction = {};
				if (0 < payloadSize) {
					transaction.transactions = [];

					var txCodec = createSubTransactionCodec(txCodecs);
					var processedSize = 0;
					while (processedSize < payloadSize) {
						var subTransaction = txCodec.deserialize(parser);
						transaction.transactions.push({ transaction: subTransaction.entity });
						processedSize += subTransaction.size;

						if (subTransaction.size < constants.sizes.embedded) throw Error('sub transaction must contain complete transaction header');
					}
				}

				// 2. deserialize cosignatures
				var numCosignatures = (size - payloadSize - constants.sizes.aggregate) / constants.sizes.cosignature;
				if (numCosignatures !== (numCosignatures | 0)) throw Error('aggregate cannot have partial cosignatures');

				if (0 < numCosignatures) {
					transaction.cosignatures = [];
					for (var i = 0; i < numCosignatures; ++i) {
						var cosignature = {};
						cosignature.signer = parser.buffer(constants.sizes.signer);
						cosignature.signature = parser.buffer(constants.sizes.signature);
						transaction.cosignatures.push(cosignature);
					}
				}

				return transaction;
			},

			serialize: function serialize(transaction, serializer, txCodecs) {
				requireCodecs(txCodecs);

				// 1. calculate payload size
				var txCodec = createSubTransactionCodec(txCodecs);

				// notice that inner tx metadata is not serialized because it is derivable
				var transactions = (transaction.transactions || []).map(function (transactionWithMetadata) {
					return transactionWithMetadata.transaction;
				});
				var subTransactionSizes = [];

				var payloadSize = 0;
				transactions.forEach(function (subTransaction) {
					var subTransactionSize = txCodec.size(subTransaction);
					subTransactionSizes.push(subTransactionSize);
					payloadSize += subTransactionSize;
				});

				serializer.writeUint32(payloadSize);

				// 2. serialize transactions
				var i = 0;
				transactions.forEach(function (subTransaction) {
					txCodec.serialize(subTransaction, serializer, subTransactionSizes[i++]);
				});

				// 3. serialize cosignatures
				if (transaction.cosignatures) {
					transaction.cosignatures.forEach(function (cosignature) {
						serializer.writeBuffer(cosignature.signer);
						serializer.writeBuffer(cosignature.signature);
					});
				}
			}
		};

		codecBuilder.addTransactionSupport(EntityType.aggregateComplete, aggregateBuilder);
		codecBuilder.addTransactionSupport(EntityType.aggregateBonded, aggregateBuilder);
	}
};

module.exports = aggregatePlugin;
//# sourceMappingURL=aggregate.js.map