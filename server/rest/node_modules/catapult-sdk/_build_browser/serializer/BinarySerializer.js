'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright (c) 2016-present,
 * Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp. All rights reserved.
 *
 * This file is part of Catapult.
 *
 * Catapult is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Catapult is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Catapult.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @module serializer/BinarySerializer */

var BufferContainer = function () {
	function BufferContainer(size) {
		_classCallCheck(this, BufferContainer);

		this.buffer = Buffer.alloc(size, 0);
		this.offset = 0;
	}

	_createClass(BufferContainer, [{
		key: 'requireBufferSpace',
		value: function requireBufferSpace(size) {
			var bytesLeft = this.buffer.length - this.offset;
			if (size > bytesLeft) throw Error('insufficient buffer space left (' + size + ' bytes required, ' + bytesLeft + ' bytes available)');
		}
	}, {
		key: 'writeUint8',
		value: function writeUint8(value) {
			this.requireBufferSpace(1);
			this.buffer.writeUInt8(value, this.offset);
			++this.offset;
		}
	}, {
		key: 'writeUint16',
		value: function writeUint16(value) {
			this.requireBufferSpace(2);
			this.buffer.writeUInt16LE(value, this.offset);
			this.offset += 2;
		}
	}, {
		key: 'writeUint32',
		value: function writeUint32(value) {
			this.requireBufferSpace(4);
			this.buffer.writeUInt32LE(value, this.offset);
			this.offset += 4;
		}
	}, {
		key: 'writeUint64',
		value: function writeUint64(value) {
			this.requireBufferSpace(8);
			this.writeUint32(value[0]);
			this.writeUint32(value[1]);
		}
	}, {
		key: 'writeBuffer',
		value: function writeBuffer(buffer) {
			var _this = this;

			this.requireBufferSpace(buffer.length);
			buffer.forEach(function (byte) {
				_this.writeUint8(byte);
			});
		}
	}]);

	return BufferContainer;
}();

/**
 * Provides an interface for writing to a fixed size buffer.
 */


var BinarySerializer = function () {
	/**
  * Creates a binary serializer.
  * @param {numeric} size The size of the underlying fixed size buffer.
  */
	function BinarySerializer(size) {
		_classCallCheck(this, BinarySerializer);

		if (!Number.isInteger(size) || 0 >= size) throw Error('BinarySerializer constructor needs integer size > 0');

		this.container = new BufferContainer(size);
	}

	/**
  * Gets the size of the underlying fixed size buffer.
  * @returns {Numeric} The size of the underlying buffer.
  */


	_createClass(BinarySerializer, [{
		key: 'bufferSize',
		value: function bufferSize() {
			return this.container.buffer.length;
		}

		/**
   * Gets the underlying fixed size buffer.
   * @returns {Buffer} The underlying buffer.
   */

	}, {
		key: 'buffer',
		value: function buffer() {
			return this.container.buffer;
		}

		/**
   * Writes a uint8 to the working buffer.
   * @param {numeric} value The value to write.
   */

	}, {
		key: 'writeUint8',
		value: function writeUint8(value) {
			this.container.writeUint8(value);
		}

		/**
   * Writes a uint16 to the working buffer.
   * @param {numeric} value The value to write.
   */

	}, {
		key: 'writeUint16',
		value: function writeUint16(value) {
			this.container.writeUint16(value);
		}

		/**
   * Writes a uint32 to the working buffer.
   * @param {numeric} value The value to write.
   */

	}, {
		key: 'writeUint32',
		value: function writeUint32(value) {
			this.container.writeUint32(value);
		}

		/**
   * Writes a uint64 to the working buffer.
   * @param {numeric} value The value to write.
   */

	}, {
		key: 'writeUint64',
		value: function writeUint64(value) {
			this.container.writeUint64(value);
		}

		/**
   * Writes a buffer of bytes to the working buffer.
   * @param {Buffer} buffer The buffer to write.
   */

	}, {
		key: 'writeBuffer',
		value: function writeBuffer(buffer) {
			this.container.writeBuffer(buffer);
		}
	}]);

	return BinarySerializer;
}();

module.exports = BinarySerializer;
//# sourceMappingURL=BinarySerializer.js.map